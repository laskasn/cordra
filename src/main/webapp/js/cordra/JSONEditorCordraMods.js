(function(){
"use strict";

// mods for required; put these first so we can inherit from them

function extendAndReplaceEditorForRequiredStars(editor) {
    var oldEditor = JSONEditor.defaults.editors[editor];
    JSONEditor.defaults.editors[editor] = oldEditor.extend({
        init: function (options) {
            this._super(options);
            this.addStar = false;
            if (this.parent) {
                var actualParent = this.parent;
                while (actualParent.path === this.path) {
                    if (actualParent.parent) actualParent = actualParent.parent;
                    else break;
                }
                this.addStar = actualParent.schema.type === 'array' || ($.isArray(actualParent.schema.required) && actualParent.schema.required.indexOf(this.key) > -1);
            }
        },
        getHeaderText: function () {
            var res = this._super();
            if (this.addStar && res.charAt(res.length - 1) !== '*') return res + " *";
            else return res;
        },
        getTitle: function () {
            var res = this._super();
            if (this.addStar && res.charAt(res.length - 1) !== '*') return res + " *";
            else return res;
        }
    });
    JSONEditor.defaults.editors[editor].options = oldEditor.options;
}
extendAndReplaceEditorForRequiredStars("string");
extendAndReplaceEditorForRequiredStars("number");
extendAndReplaceEditorForRequiredStars("integer");
extendAndReplaceEditorForRequiredStars("select");

// make non-required enums undefined by default
var oldSelectEditor = JSONEditor.defaults.editors.select;
JSONEditor.defaults.editors.select = oldSelectEditor.extend({
    getDefault: function () {
        if (!this.isRequired()) return "";
        else return this._super();
    },
    preBuild: function() {
        this._super();
        // fix enum_options
        if (!this.isRequired() && (this.schema["enum"] || this.schema.type === "boolean")) {
            this.enum_options[0] = "";
            this.enum_values[0] = "";
        }
    }
});
JSONEditor.defaults.editors.select.options = oldSelectEditor.options;

var oldTableEditor = JSONEditor.defaults.editors.table;
JSONEditor.defaults.editors.table = oldTableEditor.extend({
    preBuild: function () {
        this._super();
        this.item_title = this.item_title + " *";
    },
    getItemTitle: function () {
        var len = this.item_title.length;
        if (len < 2 || this.item_title.charAt(len-2) !== ' ' || this.item_title.charAt(len-1) !== '*') return this.item_title;
        return this.item_title.substring(0, this.item_title.length - 2);
    }
});
JSONEditor.defaults.editors.table.options = oldTableEditor.options;

// Fix up objects by removing non-required properties which would be empty
var oldObjectEditor = JSONEditor.defaults.editors.object;
JSONEditor.defaults.editors.object = oldObjectEditor.extend({
    isRequired: function (editor) {
        if (!this.jsoneditor.options.disabled) {
            // treat everything as required so that all fields show up in the UI
            return true;
        } else {
            return this._super(editor);
        }
    },
    refreshValue: function () {
        this._super();
        var required = this.schema.required;
        var hasRequired = $.isArray(required);
        for (var i in this.editors) {
            if (!this.editors.hasOwnProperty(i)) continue;
            if (hasRequired && required.indexOf(i) > -1) continue;
            if (isAutoGenerated(this.editors[i].schema)) continue;
            if (this.editors[i].cnriFileExists) continue;
            var val = this.value[i];
            if (!val) delete this.value[i];
            else if ($.isPlainObject(val) && $.isEmptyObject(val)) delete this.value[i];
            else if ($.isArray(val) && val.length === 0) delete this.value[i];
        }
    },
    getHeaderText: function () {
        // fix up templating for missing properties
        if (this.header_text) this.header_text = this.header_text.replace(/{{.*}}/g, '');
        return this._super();
    }
});
JSONEditor.defaults.editors.object.options = oldObjectEditor.options;

function isAutoGenerated(schema) {
    var fieldNode = SchemaUtil.getDeepCordraSchemaProperty(schema, 'type', 'autoGeneratedField');
    if (!fieldNode) return false;
    return true;
}


// other mods

JSONEditor.defaults.editors.uriFormat = JSONEditor.defaults.editors.string.extend({
    build: function() {
        this._super();
        var editor = this;
        var textInput = $(this.input);
        this.uriEditor = new UriEditor(textInput, editor);
    },
    enable: function() {
        this.uriEditor.enable();
        this._super();
    },
    disable: function() {
        this.uriEditor.disable();
        this._super();
    }
});

JSONEditor.defaults.resolvers.unshift(function(schema) {
    if (schema.format === "uri") {
        return "uriFormat";
    }
});

JSONEditor.defaults.editors.handleReferenceType = JSONEditor.defaults.editors.string.extend({
    build: function() {
        this._super();
        var editor = this;
        var textInput = $(this.input);
        new HandleRefSearchSelector(textInput, editor);
    }
});

JSONEditor.defaults.resolvers.unshift(function(schema) {
    if (SchemaUtil.getDeepCordraSchemaProperty(schema, 'type', 'handleReference')) {
        return "handleReferenceType";
    }
});

JSONEditor.defaults.editors.suggestedVocabulary = JSONEditor.defaults.editors.string.extend({
    build: function() {
        this._super();
        var editor = this;
        var textInput = $(this.input);
        this.suggestedVocabularySelector = new SuggestedVocabularySelector(textInput, editor);
    },
    enable: function() {
        this.suggestedVocabularySelector.enable();
        this._super();
    },
    disable: function() {
        this.suggestedVocabularySelector.disable();
        this._super();
    }
});

JSONEditor.defaults.resolvers.unshift(function(schema) {
    if (SchemaUtil.getDeepCordraSchemaProperty(schema, 'type', 'suggestedVocabulary')) {
        return "suggestedVocabulary";
    }
});


JSONEditor.defaults.editors.autoGeneratedField = JSONEditor.defaults.editors.string.extend({
    build: function() {
        this._super();
        var editor = this;
        var textInput = $(this.input);
        new AutoGeneratedField(textInput, editor);
    }
});

JSONEditor.defaults.resolvers.unshift(function(schema) {
    var fieldNode = SchemaUtil.getDeepCordraSchemaProperty(schema, 'type', 'autoGeneratedField');
    if (fieldNode) {
        return "autoGeneratedField";
    }
});

JSONEditor.defaults.editors.jsonEditor = JSONEditor.defaults.editors.string.extend({
    build: function() {
        var self = this;
        this._super();
        this.source_code = false;
        var editor = this;
        var textInput = $(this.input);
        this.containerJQuery = $('<div style="height: 500px; display:block; width:100%;"/>');
        textInput.after(this.containerJQuery);
        textInput.hide();
        var container = this.containerJQuery[0];
        var options = {
                ace: ace,
                theme: 'ace/theme/textmate',
                mode: 'code',
                //modes: ['code'], // allowed modes
                onError: function (err) {
                  APP.notifications.alertError(err.toString());
                },
                onChange: function() {
                    self.refreshValue();
                    if (self.watch_listener) self.watch_listener();
                    self.jsoneditor.notifyWatchers(self.path);
                    if(self.parent) self.parent.onChildEditorChange(self);
                    else self.jsoneditor.onChange();
                }
              };
        this.jsonEditorOnline = new JsonEditorOnline(container, options);
    },
    refreshValue: function() {
        try {
            this.value = this.jsonEditorOnline.get();
            this.serialized = JSON.stringify(this.value);
        } catch (e) {
            // ignore
        }
    },
    setValue: function(value,initial,from_template) {
        var self = this;

        if(this.template && !from_template) {
            return;
        }

        value = value || null;
        if(JSON.stringify(value) === this.serialized) return;

        this.jsonEditorOnline.set(value);

//        var changed = from_template || this.getValue() !== value;
//
        this.refreshValue();

//        if(changed) {
            if(self.parent) self.parent.onChildEditorChange(self);
            else self.jsoneditor.onChange();
//        }

        this.watch_listener();
        this.jsoneditor.notifyWatchers(this.path);
    },
    enable: function() {
        this.jsonEditorOnline.aceEditor.setReadOnly(false);
        this.containerJQuery.find('.ace_content').css('background-color', '');
        this._super();
    },
    disable: function() {
        this.jsonEditorOnline.aceEditor.setReadOnly(true);
        this.containerJQuery.find('.ace_content').css('background-color', '#eee');
        this._super();
    },
    destroy: function() {
        this.jsonEditorOnline.destroy();
        this._super();
    }
});

JSONEditor.defaults.resolvers.unshift(function(schema) {
    var format = JsonUtil.getDeepProperty(schema, 'format');
    if ('json' === format) {
        return "jsonEditor";
    }
});

JSONEditor.defaults.themes.bootstrap3 = JSONEditor.defaults.themes.bootstrap3.extend({
    getButton: function(text, icon, title) {
      var el = this._super(text, icon, title);
      el.className += ' btn-sm';
      return el;
    }
});

})();
